export const data = JSON.parse("{\"key\":\"v-46e51655\",\"path\":\"/java/juc.html\",\"title\":\"Java 并发编程\",\"lang\":\"zh-CN\",\"frontmatter\":{\"order\":3,\"description\":\"线程的创建 1. 继承 Thread 类 2. 实现 Runnable 接口 3. 实现 Callable 接口并使用 FutureTask 4. 使用线程池 线程池 是什么 是一个线程的资源池，有任务时直接从线程池中取出线程来处理，处理完后不立即销毁，而是等待下一个任务。 线程池的参数 线程池的执行原理 1. 判断核心线程数是否已满，若没有，则创建线...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://vuepress-theme-hope-docs-demo.netlify.app/java-interview/java/juc.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"后端面试经验\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Java 并发编程\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"线程的创建 1. 继承 Thread 类 2. 实现 Runnable 接口 3. 实现 Callable 接口并使用 FutureTask 4. 使用线程池 线程池 是什么 是一个线程的资源池，有任务时直接从线程池中取出线程来处理，处理完后不立即销毁，而是等待下一个任务。 线程池的参数 线程池的执行原理 1. 判断核心线程数是否已满，若没有，则创建线...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Ding\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Java 并发编程\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Ding\\\",\\\"url\\\":\\\"https://github.com/prgding\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"线程的创建\",\"slug\":\"线程的创建\",\"link\":\"#线程的创建\",\"children\":[]},{\"level\":2,\"title\":\"线程池\",\"slug\":\"线程池\",\"link\":\"#线程池\",\"children\":[{\"level\":3,\"title\":\"是什么\",\"slug\":\"是什么\",\"link\":\"#是什么\",\"children\":[]},{\"level\":3,\"title\":\"线程池的参数\",\"slug\":\"线程池的参数\",\"link\":\"#线程池的参数\",\"children\":[]},{\"level\":3,\"title\":\"线程池的执行原理\",\"slug\":\"线程池的执行原理\",\"link\":\"#线程池的执行原理\",\"children\":[]},{\"level\":3,\"title\":\"线程池的拒绝策略\",\"slug\":\"线程池的拒绝策略\",\"link\":\"#线程池的拒绝策略\",\"children\":[]}]},{\"level\":2,\"title\":\"进程和线程的区别\",\"slug\":\"进程和线程的区别\",\"link\":\"#进程和线程的区别\",\"children\":[]},{\"level\":2,\"title\":\"有了进程为什么还需要线程?\",\"slug\":\"有了进程为什么还需要线程\",\"link\":\"#有了进程为什么还需要线程\",\"children\":[]},{\"level\":2,\"title\":\"synchronized 的作用\",\"slug\":\"synchronized-的作用\",\"link\":\"#synchronized-的作用\",\"children\":[]},{\"level\":2,\"title\":\"volatile 关键字\",\"slug\":\"volatile-关键字\",\"link\":\"#volatile-关键字\",\"children\":[]},{\"level\":2,\"title\":\"CAS\",\"slug\":\"cas\",\"link\":\"#cas\",\"children\":[]},{\"level\":2,\"title\":\"ReentrantLock 可重入锁相比于 sychronized\",\"slug\":\"reentrantlock-可重入锁相比于-sychronized\",\"link\":\"#reentrantlock-可重入锁相比于-sychronized\",\"children\":[]}],\"readingTime\":{\"minutes\":2.95,\"words\":886},\"filePathRelative\":\"java/juc.md\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
