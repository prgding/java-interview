export const data = JSON.parse("{\"key\":\"v-46e51655\",\"path\":\"/java/juc.html\",\"title\":\"Java 并发编程\",\"lang\":\"zh-CN\",\"frontmatter\":{\"order\":3,\"icon\":\"healthicons:3-outline\",\"description\":\"线程的创建 1. 继承 Thread 类 2. 实现 Runnable 接口 3. 实现 Callable 接口并使用 FutureTask 4. 使用线程池 Runnable、Callable 的区别 1. Runnable 接口没有返回值，Callable 接口可以有一个泛型的返回值。 2. Runnable 的 run 方法不能抛出异常，任务异常...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://vuepress-theme-hope-docs-demo.netlify.app/java-interview/java/juc.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"后端开发经验\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Java 并发编程\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"线程的创建 1. 继承 Thread 类 2. 实现 Runnable 接口 3. 实现 Callable 接口并使用 FutureTask 4. 使用线程池 Runnable、Callable 的区别 1. Runnable 接口没有返回值，Callable 接口可以有一个泛型的返回值。 2. Runnable 的 run 方法不能抛出异常，任务异常...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-11-08T06:46:34.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Ding\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-11-08T06:46:34.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Java 并发编程\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":\\\"2023-11-08T06:46:34.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Ding\\\",\\\"url\\\":\\\"https://github.com/prgding\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"线程的创建\",\"slug\":\"线程的创建\",\"link\":\"#线程的创建\",\"children\":[]},{\"level\":2,\"title\":\"Runnable、Callable 的区别\",\"slug\":\"runnable、callable-的区别\",\"link\":\"#runnable、callable-的区别\",\"children\":[]},{\"level\":2,\"title\":\"线程池\",\"slug\":\"线程池\",\"link\":\"#线程池\",\"children\":[{\"level\":3,\"title\":\"是什么\",\"slug\":\"是什么\",\"link\":\"#是什么\",\"children\":[]},{\"level\":3,\"title\":\"线程池的参数\",\"slug\":\"线程池的参数\",\"link\":\"#线程池的参数\",\"children\":[]},{\"level\":3,\"title\":\"线程池的执行原理\",\"slug\":\"线程池的执行原理\",\"link\":\"#线程池的执行原理\",\"children\":[]},{\"level\":3,\"title\":\"线程池的拒绝策略\",\"slug\":\"线程池的拒绝策略\",\"link\":\"#线程池的拒绝策略\",\"children\":[]}]},{\"level\":2,\"title\":\"进程和线程的区别\",\"slug\":\"进程和线程的区别\",\"link\":\"#进程和线程的区别\",\"children\":[]},{\"level\":2,\"title\":\"有了进程为什么还需要线程?\",\"slug\":\"有了进程为什么还需要线程\",\"link\":\"#有了进程为什么还需要线程\",\"children\":[]},{\"level\":2,\"title\":\"synchronized 的作用\",\"slug\":\"synchronized-的作用\",\"link\":\"#synchronized-的作用\",\"children\":[]},{\"level\":2,\"title\":\"volatile 关键字\",\"slug\":\"volatile-关键字\",\"link\":\"#volatile-关键字\",\"children\":[]},{\"level\":2,\"title\":\"CAS\",\"slug\":\"cas\",\"link\":\"#cas\",\"children\":[]},{\"level\":2,\"title\":\"ReentrantLock 可重入锁相比于 sychronized\",\"slug\":\"reentrantlock-可重入锁相比于-sychronized\",\"link\":\"#reentrantlock-可重入锁相比于-sychronized\",\"children\":[{\"level\":3,\"title\":\"ReentrantLock 使用场景\",\"slug\":\"reentrantlock-使用场景\",\"link\":\"#reentrantlock-使用场景\",\"children\":[]}]},{\"level\":2,\"title\":\"ExecutorService 使用场景\",\"slug\":\"executorservice-使用场景\",\"link\":\"#executorservice-使用场景\",\"children\":[]}],\"git\":{\"createdTime\":1694007096000,\"updatedTime\":1699425994000,\"contributors\":[{\"name\":\"ding\",\"email\":\"69354087+prgding@users.noreply.github.com\",\"commits\":6},{\"name\":\"dings\",\"email\":\"1203823603@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":4.38,\"words\":1314},\"filePathRelative\":\"java/juc.md\",\"localizedDate\":\"2023年9月6日\",\"autoDesc\":true}")
