---
order: 2
icon: healthicons:2-outline
---

# JVM

## JVM 架构

1. **类加载器**
    1. 加载
        1. 双亲委派
    2. 链接
        1. 验证
        2. 准备
        3. 解析
    3. 初始化
2. **运行时数据区域**
3. **执行引擎**
    1. 解释器
        1. 读取 class 文件或者字节码并执行。
        2. 缺点：如果一个方法被多次调用，代码会被它多次编译
    2. JIT 编译器
        1. 解决了解释器的问题
        2. 如果出现了重复调用，JIT 会把字节码编译成本地代码，能够直接被调用
        3. 组件
            1. 中间代码生成器
            2. 代码优化器
            3. 目标代码生成器：将中间代码转换为本地机器码
            4. profiler：定位重复被调用的热点代码
    3. 垃圾回收器
    4. Java 本地方法接口：负责与本地库交互，提供给 JVM 执行引擎使用

## JVM 运行流程

1. 类加载器采用双亲委派机制**加载** .class 文件
2. **链接**：
    1. 验证：确保字节码安全、结构完整
    2. 准备：为类变量分配内存、初始化默认值
    3. 解析：将符号引用转为直接引用
3. **初始化**：类初始化、静态代码块执行、类的全局变量赋值
4. 使用：执行主类的 main 方法
5. 类卸载

## 运行时数据区域

1. 线程共享：
    1. **堆**
        1. 保存对象实例、数组等
        2. 垃圾回收的主要区域
        3. 内存不够抛出异常 OutOfMemoryError
        4. （1.7）**方法区**（概念）：永久代（具体实现）：存储类信息、类变量、方法信息、常量
2. 线程私有
    1. **栈**
        1. 虚拟机栈
        2. 本地方法栈
    2. **程序计数器**
3. 本地内存
    1. 直接内存
    2. （1.8）方法区：元空间：存储类信息、类变量、方法信息、常量

## 垃圾回收机制

### 对象什么时候被回收

1. 对于引用计数法，对象的引用计数为 0 时被回收，但是难以解决循环引用问题。
2. 对于可达性分析法，当对象与 GC Roots 没有关联时会被回收。

### 垃圾回收算法

1. 标记 - 清除
    1. 使用可达性分析标记出存活对象，然后把其他的回收掉。
    2. 缺点是会产生不连续的内存碎片。
2. 标记 - 整理
    1. 使用可达性分析标记存活。
    2. 存活对象向一端移动，清理边界以外的内存。
3. 复制
    1. 将内存分为两块，回收时将存活对象复制到另一块，然后把原来的空间清空。
    2. 缺点是内存缩小为原来的一半，且存活数量大时，复制性能差。

4. 分代收集
    1. 当前虚拟机都采用这种方式。
    2. 将 Java 堆分成新生代和老年代。
    3. 新生代经常会有大量对象死去，可以使用标记-复制。
    4. 老年代中存活几率比较高，而且没有额外空间进行分配，可以选择标记-清除或标记-整理。

## 双亲委派机制

### 是什么

当类加载器加载一个类时，加载器会委托父类加载器完成，父类加载器会再去找父类，就这样一直传递到顶层。只有当父加载器无法加载时，子加载器才会加载这个类。

### 为什么使用双亲委派？

- 防止一个类重复加载
- Java 核心类库由 Bootstrap ClassLoader 加载，可以防止核心类库代码不被恶意篡改或替换
- 维护程序安全性和稳定性

### 打破双亲委派机制

#### 哪些场景需要打破该机制？

1. 热部署：能够重新加载修改过的类
2. Tomcat：Tomcat 中需要用到热部署，以及类隔离。类隔离可以实现部署多个 Web 应用。

#### 如何打破该机制

1. 继承 ClassLoader，自定义一个加载器
2. 重写 loadClass() 方法

### 注意事项

- 双亲委派规定：一个类及其依赖类要由同一个类加载器加载
- 但是可能会遇到下面的情况
    1. Java 的 SPI （Service Provider Interface）
        1. SPI 接口，例如 `java.sql.Driver`是由核心库提供的，应该用 Bootstrap ClassLoader 加载。
        2. 但是 SPI 的实现例如 `com.mysql.cj.jdbc.Driver` 由第三方供应，要由 Applicaiton ClassLoader 或者自定义加载器加载。
    2. Spring 的 jar 包
        1. Spring 的 jar 包应该是 Web 应用共享的，如果使用 Tomcat，要用 Tomcat 中的 Shared ClassLoader 加载
        2. 但是项目的其他地方还会用到 Spring 提供的业务类、接口实现、注解等，那么按照规定，Shared ClassLoader 也要加载这些内容。
        3. 但是这些类是单个Web程序私有的，并不是共享的，所以 Shared ClassLoader 加载不了它们。
- 这些情况下，SPI 高层类加载器需要加载低层的类，或 Spring 的不同部分要被不同的类加载器加载。
- 如何解决这个问题呢？
- 可以使用 **线程上下文 类加载器（ThreadContext ClassLoader）**
